[{"categories":["opencv"],"content":"介绍 归一化和标准化都是对数据做变换，将原始的一组数据转换到某个范围或者说到某种状态。在数据处理的时候我们常会碰到如下三种处理： 归一化（Normalization）：将一组数据变化到某个固定区间内，比较常见的如[0, 1]。广义来说可以是各种区间，比如在对图像进行处理是会经常映射到[0, 255]，也有映射到[-1, 1]的情况 标准化（Standardization）：将一组数据变换为均值为0，标准差为1的分布（该分布并非一定符合正态分布） 中心化：中心化也叫零均值处理，就是用一组原始数据减去这些数据的均值。比如在ICP算法中会先对数据进行中心化 联系和区别 本质上，归一化和标准化都是对数据做线性变换。 但是也存在一些区别。比如第一，归一化会严格的限定变换后数据的区间。而标准化没有严格的区间限定，只是其数据的均值为0，标准差为1。第二，归一化对数据的缩放比例仅仅和极值有关，比如100个数，你除去极大值和极小值其他数据都更换掉，缩放比例是不变的；但是标准化中，如果除去极大值和极小值其他数据都更换掉，那么均值和标准差大概率会改变，这时候，缩放比例自然也改变了。 标准化和归一化的多种形式 广义的说，标准化和归一化同为对数据的线性变化，所以我们没必要规定死，归一化就是必须到[ 0 , 1]之间，我到[ 0 , 1 ]之间之后再乘一个255也没有问题对吧。常见的有以下几种： 归一化的最通用模式Normalization，也称线性归一化： 均值归一化 （Mean normalization）： 标准化(Standardization)，也叫标准差标准化： 标准化、归一化的原因、用途 为何统计模型、机器学习和深度学习任务中经常涉及到数据(特征)的标准化和归一化呢，一半原因以下几点，当然可能还有一些其他的作用，大家见解不同，我说的这些是通常情况下的原因和用途。 统计建模中，如回归模型，自变量X 的量纲不一致导致了回归系数无法直接解读或者错误解读；需要将X都处理到统一量纲下，这样才可比； 机器学习任务和统计学任务中有很多地方要用到“距离”的计算，比如PCA，比如KNN，比如kmeans等等，假使算欧式距离，不同维度量纲不同可能会导致距离的计算依赖于量纲较大的那些特征而得到不合理的结果； 参数估计时使用梯度下降，在使用梯度下降的方法求解最优化问题时， 归一化/标准化后可以加快梯度下降的求解速度，即提升模型的收敛速度。 什么时候Standardization，什么时候Normalization 如果对输出结果范围有要求，用归一化 如果数据较为稳定，不存在极端的最大最小值，用归一化 如果数据存在异常值和较多噪音，用标准化，可以间接通过中心化避免异常值和极端值的影响 cv::normalize() 函数介绍 void normalize(InputArray src, OutputArray dst, double alpha=1, double beta=0, int norm_type=NORM_L2, int dtype=-1, InputArray mask=noArray()); 参数 src - 输入数组 dst - 输出数组，支持原地运算 alpha - range normalization模式的最小值 beta - range normalization模式的最大值，不用于norm normalization(范数归一化)模式。 norm_type - 归一化的类型，可以有以下的取值 NORM_MINMAX:数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。比如归一化到[min, max]范围内，则计算公式如下： NORM_INF: 归一化数组的无穷范数(绝对值的最大值)。每个值除以最大值来进行无穷范数归一化。同上最终归一化的值为单位向量的每个值乘以参数要归一化的范数值alpha NORM_L1 : 归一化数组的L1-范数(绝对值的和)。数组元素绝对值求和，然后算出每一个元素比上总和的比值，加起来总为1。这里要归一化的范数值为1.0，所求出的比值即为最后归一化后的值，若归一化范数值alpha为2.0，则每个比值分别乘以2.0即得到最后归一化后的结果为0.2, 0.8, 1.0，以此类推 NORM_L2: 归一化数组的L2-范数(各元素的平方和然后求平方根 ，欧氏距离)。即将该向量归一化为单位向量，每个元素值除以该向量的模长。同上最终归一化的值为单位向量的每个值乘以参数要归一化的范数值alpha dtype - 为负值时, 输出数据类型和输入数据类型一致，否则和src通道一致，depth =CV_MAT_DEPTH(dtype) mask - 掩码。选择感兴趣区域，选定后只能对该区域进行操作。 参考链接 ","date":"2022-07-14","objectID":"/opencv%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96%E5%92%8C%E5%BD%92%E4%B8%80%E5%8C%96/:0:0","tags":["opencv"],"title":"Opencv数据标准化和归一化","uri":"/opencv%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96%E5%92%8C%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["软件安装"],"content":"介绍 Git 是目前世界上被最广泛使用的现代软件版本管理系统。Git 本身亦是一个成熟并处于活跃开发状态的开源项目，它最初是由 Linux 操作系统内核的创造者 Linus Torvalds 在 2005 年创造。今天惊人数量的软件项目依赖 Git 进行版本管理，这些项目包括开源以及各种商业软件。Git 在职业软件开发者中拥有良好的声誉，Git 目前支持绝大多数的操作系统以及 IDE（Integrated Development Environments）。 快速指南 该快速指南是面向从零开始的读者。 ","date":"2022-07-14","objectID":"/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8Avscode%E5%8F%AF%E8%A7%86%E5%8C%96git/:0:0","tags":["Git"],"title":"Git快速入门以及VScode可视化Git","uri":"/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8Avscode%E5%8F%AF%E8%A7%86%E5%8C%96git/"},{"categories":["软件安装"],"content":"安装Git Linux ： sudo apt-get install git Git 的高质量中文教程 https://github.com/geeeeeeeeek/git-recipes.git vs code上 Git可视化教程 https://cloud.tencent.com/developer/article/1793472 ","date":"2022-07-14","objectID":"/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8Avscode%E5%8F%AF%E8%A7%86%E5%8C%96git/:1:0","tags":["Git"],"title":"Git快速入门以及VScode可视化Git","uri":"/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8Avscode%E5%8F%AF%E8%A7%86%E5%8C%96git/"},{"categories":["软件安装"],"content":"前言 pcl库的编译安装真心让人想吐，运气好一次通过，运气不好（各种环境的、各种依赖的问题）两三天就过去了。在这里分享下我安装pcl所遇到的问题。 通过sudo apt 安装 通过这种方式安装的最大的好处就是简单且不容易出现编译安装的问题，缺点就是可能会有部分功能无法使用 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:0:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"安装依赖 sudo apt-get update sudo apt-get install git build-essential linux-libc-dev sudo apt-get install cmake cmake-gui sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev sudo apt-get install mpi-default-dev openmpi-bin openmpi-common sudo apt-get install libflann1.9 libflann-dev sudo apt-get install libeigen3-dev sudo apt-get install libboost-all-dev sudo apt-get install libqhull* libgtest-dev sudo apt-get install freeglut3-dev pkg-config sudo apt-get install libxmu-dev libxi-dev sudo apt-get install mono-complete sudo apt-get install libopenni-dev sudo apt-get install libopenni2-dev sudo apt-get install libvtk7-dev libvtk6-dev sudo apt-get install qt5-default ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:1:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"安装PCL sudo apt-get install libpcl-dev 至此，PCL库的安装和配置就算是完成了，接下来测试一下PCL库是否可以正常运行 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:2:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"测试 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:3:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"编写源文件 写个测试用的源文件 test.cpp （网上copy的） #include \u003ciostream\u003e #include \u003cpcl/common/common_headers.h\u003e #include \u003cpcl/io/pcd_io.h\u003e #include \u003cpcl/visualization/pcl_visualizer.h\u003e #include \u003cpcl/visualization/cloud_viewer.h\u003e #include \u003cpcl/console/parse.h\u003e int main(int argc, char **argv) { std::cout \u003c\u003c \"Test PCL !!!\" \u003c\u003c std::endl; pcl::PointCloud\u003cpcl::PointXYZRGB\u003e::Ptr point_cloud_ptr (new pcl::PointCloud\u003cpcl::PointXYZRGB\u003e); uint8_t r(255), g(15), b(15); for (float z(-1.0); z \u003c= 1.0; z += 0.05) { for (float angle(0.0); angle \u003c= 360.0; angle += 5.0) { pcl::PointXYZRGB point; point.x = 0.5 * cosf (pcl::deg2rad(angle)); point.y = sinf (pcl::deg2rad(angle)); point.z = z; uint32_t rgb = (static_cast\u003cuint32_t\u003e(r) \u003c\u003c 16 | static_cast\u003cuint32_t\u003e(g) \u003c\u003c 8 | static_cast\u003cuint32_t\u003e(b)); point.rgb = *reinterpret_cast\u003cfloat*\u003e(\u0026rgb); point_cloud_ptr-\u003epoints.push_back (point); } if (z \u003c 0.0) { r -= 12; g += 12; } else { g -= 12; b += 12; } } point_cloud_ptr-\u003ewidth = (int) point_cloud_ptr-\u003epoints.size (); point_cloud_ptr-\u003eheight = 1; pcl::visualization::CloudViewer viewer (\"test\"); viewer.showCloud(point_cloud_ptr); while (!viewer.wasStopped()){ }; return 0; } ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:3:1","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"编写CMakeLists.txt 在目录下创建TestPCL文件夹，用于存储测试项目的文件，将test.cpp和CMakeLists.txt存储至TestPCL文件夹，创建TestPCL/bulid文件夹以储存中间文件。 cmake_minimum_required(VERSION 2.6) project(TEST) find_package(PCL REQUIRED) include_directories(${PCL_INCLUDE_DIRS}) link_directories(${PCL_LIBRARY_DIRS}) add_definitions(${PCL_DEFINITIONS}) add_executable(TEST test.cpp) target_link_libraries (TEST ${PCL_LIBRARIES}) install(TARGETS TEST RUNTIME DESTINATION bin) ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:3:2","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"编译安装运行 cd build cmake .. make ./TEST ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:3:3","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"正常运行结果 通过源码安装 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:3:4","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"安装PCL依赖 sudo apt-get update sudo apt-get install git build-essential linux-libc-dev sudo apt-get install cmake cmake-gui sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev sudo apt-get install mpi-default-dev openmpi-bin openmpi-common sudo apt-get install libflann1.9 libflann-dev # 有说ubuntu16对应1.8，ubuntu18对应1.9，我直接用了1.9 sudo apt-get install libeigen3-dev sudo apt-get install libboost-all-dev sudo apt-get install libqhull* libgtest-dev sudo apt-get install freeglut3-dev pkg-config sudo apt-get install libxmu-dev libxi-dev sudo apt-get install mono-complete sudo apt-get install libopenni-dev sudo apt-get install libopenni2-dev ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:4:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"安装VTK ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:5:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"安装vtk依赖 #首先安装VTK的依赖：X11，OpenGL；cmake和cmake-gui在安装pcl依赖的时候安装过了的话可以跳过 sudo apt-get install libx11-dev libxext-dev libxtst-dev libxrender-dev libxmu-dev libxmuu-dev #OpenGL sudo apt-get install build-essential libgl1-mesa-dev libglu1-mesa-dev #cmake \u0026\u0026 cmake-gui sudo apt-get install cmake cmake-gui ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:5:1","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"下载vtk 官网下载链接：Download | VTK 这里要注意以下VTK 和 PCL 版本之间的兼容性。我不确切肯定有版本兼容的问题，只是在我尝试了不同VTK版本后，发现VTK版本和PCL的版本还是有一定要求的。最好安装两者的版本如下（自己尝试过）: ubuntu版本呢 pcl 版本 vtk版本 18.04 / 20.04 1.9.1 8.2.0 18.04 / 20.04 1.8.1 7.1.1 16.04 1.7.2 5.10.1 /6.2.0 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:5:2","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"编译安装 下载完成之后解压到准备好的安装目录，再通过终端打开 cmake GUI 模式 cmake-gui 在cmake-gui中： 配置 where is the source code 为VTK-8.2.0所在目录。（然后在VTK-8.2.0所在目录下新建一个build文件夹） 配置 where to build the binaries 为VTK-8.2.0下的build文件夹 点击Configure，（用“Unix Makefiles”就可以）。配置完成后，显示“Configuring done” 勾选VTK-Group-Qt，VTK_QT_VERSION选为5，再点击Configure，配置完成后，显示“Configuring done” 点击Generate，显示“Generating done”，在build文件夹下生成工程文件 推出cmake-gui 在终端里切换到VTK-8.2.0安装目录下的build文件夹 make -j4 #性能好内存大的电脑就用 -j8 吧 sudo make install ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:5:3","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"安装PCL 官网下载连接：Releases · PointCloudLibrary/pcl 到PCL的github主页下载需要的版本(这里我下载的1.9.1)，放到准备好的安装目录下。打开终端，进到pcl的安装目录下： mkdir build cd build # 设置CMAKE_INSTALL_PREFIX是为了把pcl安装到指定文件夹内，所以这个路径根据自己的情况设置 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/pcl-1.9.1 -DCMAKE_TYPE=None .. make -j4 #一样的，根据实际情况调整 sudo make install ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:6:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"测试 同上 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:7:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"遇到的问题 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:8:0","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"问题1 在make pcl的时候，报错：“/usr/bin/ld: cannot find -lvtkIOMPIImage /usr/bin/ld: cannot find -lvtkIOMPIParallel /usr/bin/ld: cannot find -lvtkFiltersParallelDIY2” 解决方案 重新编译安装 vtk。在cmake-gui模式下，完成第3步的Configure，然后勾选Advanced，在search中把/usr/bin/ld找不到的vtkIOMPIImage，vtkIOMPIParallel，vtkFiltersParallelDIY2都选上。包括如果出现了类似的问题也可以县看看这里面是否可以选上的。 再点击Configure，显示“Configuring done”，点击Generate，显示“Generating done”。 打开终端，完成 make 和 sudo make install ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:8:1","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"问题2 cmake pcl 的时候，提示Checking for module ‘metslib’ – No package ‘metslib’ found 解决方案 安装metslib（我用的是0.5.3版本） 下载链接：https://www.coin-or.org/download/source/metslib/metslib-0.5.3.tgz 解压后，在metslib-0.53打开命令终端并执行 sudo sh ./configure sudo make sudo make install 顺利完成安装metslib ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:8:2","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"问题3 No rule to make target in /usr/lib/x86_64-linux-gnu/libpcl_surface. so **后面的内容不记得了** 解决方案 lcoate libpcl_surface. so /usr/lib/x86_64-linux-gnu/libpcl_surface.so.1.10 结果没有上面说的libpcl_surface. so，这是因为我之前通过sudo apt install libpcl-dev 安装过pcl，所以动态库还保留在那里。 简而言之就是，要在/usr/lib/x86_64-linux-gnu/ 找libpcl_surface. so这个动态库。 所以先找到 libpcl_surface. so在哪里 whereis libpcl_surface. so libpcl_surface: /usr/lib/libpcl_surface.so 发现在/usr/lib/这个路径。所以只需要把这个路径下的动态库建立一个软链接到/usr/lib/x86_64-linux-gnu/就行。大概了，还有很多动态库都是这种情况，所以可以使用候补符号一次性解决。 sudo ln -s /usr/lib/libpcl_*.so /usr/lib/x86_64-linux-gnu 参考链接 二、PLC安装踩坑总结（Ubuntu 16.4+PCL1.8.1+VTK7.1+Qt5.9.9)_way7486chundan的博客-CSDN博客 ","date":"2022-07-14","objectID":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/:8:3","tags":["PCL"],"title":"Ubuntu20.04安装PCL库","uri":"/pcl%E5%BA%93%E5%9C%A8ubuntu20.04%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["软件安装"],"content":"简介 Latex是一个基于TEX的排班系统。粘贴复制的话就不搞了。简而言之，通俗来说，就是用来写文章的，而且完全不需要你去花时间去自己考虑排版、页码等没必要花时间去弄的玩意。而且，对于数学公式的输入也是极为方便，这点在后面会展示。 安装 安装发行版 sudo apt-get install texlive-full 安装XeLaTeX编译引擎sudo apt-get install texlive-xetex 安装中文支持包（如果需要）sudo apt-get install texlive-lang-chinese 安装编辑器（图形化界面的选择有很多，例如 TeXStudio，TeXmaker等，可以看做是一个编辑器，这里安装的是TexStudio）sudo apt-get install texstudio 配置 设置编译器为XeLaTeX，TeXstudio中在Options-\u003eConfigure TeXstudio-\u003eBuild-\u003eDefault Compiler中更改默认编译器为XeLaTeX 更改软件界面语言，将Options-\u003eConfigure TeXstudio-\u003eGeneral-\u003eLanguage改为zh-CN即可将界面设置为中文 其他工具和资源 ","date":"2022-06-30","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85latex%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/:0:0","tags":["Latex"],"title":"Ubuntu20.04安装LaTeX并配置中文环境","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85latex%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/"},{"categories":["软件安装"],"content":"Mathpix 在写论文或者文档的时候，经常会碰到要输入数学公式的情况。如果去手敲，效率很低。这里介绍一个数学公式的latex语句生成工具 Mathpix。 碰到文献里的数学公式，只需要用这个软件，就可以轻松获得这个公式的latex语句。 ","date":"2022-06-30","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85latex%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/:0:1","tags":["Latex"],"title":"Ubuntu20.04安装LaTeX并配置中文环境","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85latex%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/"},{"categories":["软件安装"],"content":"模板 模板这里分享一个latex模板网站 模板 ","date":"2022-06-30","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85latex%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/:0:2","tags":["Latex"],"title":"Ubuntu20.04安装LaTeX并配置中文环境","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85latex%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/"},{"categories":["软件安装"],"content":"APT软件包管理系统 apt-get install apt一般直接安装已经编译好的可执行文件，会直接帮你处理依赖关系，apt-get install安装目录是包的维护者确定的，不是用户。系统安装软件一般在/usr/share，可执行的文件在/usr/bin，配置文件可能安装到了/etc下等。 apt-get remove 卸载已安装的软件包（保留配置文件） apt-get remove -purge 卸载已安装的软件包同时删除配置文件 apt-get autoremove 删除为了满足其他软件包的依赖而安装的，但现在不再需要的软件包(新手注意在桌面版的Ubuntu系统下尽量不要使用) apt-get update 更新软件信息数据库 apt-get upgrade 进行系统升级，即更新已安装的包 apt-get autoclean如果你的硬盘空间不大的话，可以定期运行这个程序，将已经删除了的软件包的.deb安装文件从硬盘中删除掉。如果你仍然需要硬盘空间的话，可以试试apt-get clean，这会把你已安装的软件包的安装包也删除掉，当然多数情况下这些包没什么用了，因此这是个为硬盘腾地方的好办法。 apt-get clean 类似上面的命令，但它删除包缓存中的所有包。这是个很好的做法，因为多数情况下这些包没有用了。但如果你是拨号上网的话，就得重新考虑了。 源码 这种软件包里面都是源程序，没有编译过，经过编译后才能安装。源码安装大致可以分为三步:（./configure）–＞ 编译（sudo make） –＞ 安装（sudo make install） 配置：这是编译源代码的第一步，通过 ./configure 命令完成。执行此步以便为编译源代码作准备。常用的选项有 --prefix=PREFIX，用以指定程序的安装位置。更多的选项可通过 --help 查询。也有某些程序无需执行此步。如果配置了–prefix，如：./configure --prefix=/usr/local/test安装后的所有资源文件都会被放在/usr/local/test目录中，不会分散到其他目录。 编译：一旦配置通过，可即刻使用 make 指令来执行源代码的编译过程。视软件的具体情况而定，编译所需的时间也各有差异，我们所要做的就是耐心等候和静观其变。此步虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。较常碰到的情形是程序编译到中途却无法圆满结束。此时，需要根据出错提示分析以便找到应对之策。 安装：如果编译没有问题，那么执行 sudo make install 就可以将程序安装到系统中了。 当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载干净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）当然要卸载程序，也可以在原来的make目录下用一次make uninstall，但前提是Makefile文件有uninstall命令。 如果没有配置--prefix选项，源码包也没有提供make uninstall，则可以通过以下方式可以完整卸载：设置一个临时目录重新安装一遍，如： ./configure --prefix=/tmp/to_remove \u0026\u0026makeinstall然后遍历/tmp/to_remove的文件，删除对应安装位置的文件即可（因为/tmp/to_remove里的目录结构就是没有配置--prefix选项时的目录结构） locate 找到要卸载的软件的安装位置，然后删除所有对应的文件。例如： sudo rm -r /usr/local/include/vtk-8.2 /usr/local/lib/cmake/vtk-8.2/ /usr/local/share/doc/vtk-8.2 DPKG Ubuntu系统中，软件通常以.deb格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其他软件包的依赖关系记录、一个比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。针对dpkg来说，它只能安装一个.deb格式的包，同时会通知你安装这个包需要什么样的依赖，但是不会安装那些依赖文件，同时也对这个包进行配置，因为那些依赖包并没有下载安装。 deb软件包命令遵行如下约定： **soft_ver_rev_arch.deb**soft为软件包名，ver为版本号，rev为Ubuntu修订版本号，arch为目标架构名称 dpkg -i | --install xxx.deb 安装deb安装包 dpkg -r | --remove xxx.deb 删除安装包 dpkg -r -p |--purge xxx.deb 连同配置文件一起删除 dpkg -I | -info xxx.deb 产看软件包信息 dpkg -L xxx.deb 查看文件拷贝信息 dpkg -l 查看系统中以安装软件包信息 dpkg-reconfigure xxx 重新配置软件包 有些时候，使用dpkg安装一个软件包，系统会提示该软件包依赖其他软件包。这时，需要先安装其他软件包，知道满足依赖关系为止。或者同时安装多个软件包，如：dpkg -i aaa.deb bbb.deb ccc.deb 。但是，如果一个软件依赖关系过于复杂，使用\"dpkg\"来安装它，并不是一个明智的选择，这个时候需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过预设的方法来获得相关软件包，并自动安装配置它。事实上，在多数情况下，我们推荐使用APT软件包管理系统。 ","date":"2022-06-30","objectID":"/ubuntu%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":["Linux"],"title":"Ubuntu安装卸载基础知识","uri":"/ubuntu%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]